# Winsorized Variance Performance Benchmark Report

**Generated by**: Claude Sonnet 4  
**Date**: January 2025  
**Objective**: Investigate and optimize the performance bottleneck in `traffic_anomaly.changepoint()` with `robust=True`

## Executive Summary

After comprehensive benchmarking and optimization attempts, the **original Ibis implementation is remarkably well-optimized** and alternative implementations (Pandas/NumPy, Polars) do not provide performance improvements. However, the `robust=True` option does show significant performance degradation that scales with dataset size.

### Key Findings

- âœ… **Performance Issue Confirmed**: `robust=True` is 3-40x slower than `robust=False` depending on dataset size
- âŒ **No Faster Alternative Found**: Pandas/NumPy and Polars implementations are 11-21x slower than original Ibis
- ðŸŽ¯ **Root Cause Identified**: Complex SQL joins for quantile calculations in winsorized variance (7 JOINs, 14KB SQL query)
- ðŸ’¡ **Recommendation**: The current Ibis implementation is optimal for the SQL-based architecture
- ðŸ” **Algorithm Complexity**: The performance issue is inherent to winsorized variance computation, not implementation inefficiency

## Detailed Benchmark Results

### Performance Scaling Analysis

| Dataset Multiplier | Dataset Size | Entities | robust=False | robust=True | Slowdown Factor |
|-------------------|--------------|----------|--------------|-------------|-----------------|
| 1x | 5,768 rows | 3 | 0.17s | 0.45s | 2.6x |
| 10x | 57,680 rows | 30 | 0.11s | 2.46s | 22.4x |
| 25x | 144,200 rows | 75 | 0.16s | 5.86s | 36.6x |
| 50x | 288,400 rows | 150 | 0.32s | 12.01s | 37.5x |

### Alternative Implementation Results

| Implementation | 1x Dataset | 10x Dataset | 25x Dataset | 50x Dataset | vs Original robust=True |
|---------------|------------|-------------|-------------|-------------|-------------------------|
| Original Ibis (robust=False) | 0.17s | 0.11s | 0.16s | 0.32s | **7-37x faster** |
| Original Ibis (robust=True) | 0.45s | 2.46s | 5.86s | 12.01s | **Baseline** |
| Optimized Pandas/NumPy | 5.07s | 50.97s | 126.14s | 252.98s | **11-21x slower** |

### Parameter Optimization Results

Testing with 20x dataset (115,360 rows, 60 entities):

| Parameter Variation | Time | Result Shape | Notes |
|-------------------|------|--------------|-------|
| 7-day window | 3.21s | (240, 6) | **Fastest** - smaller windows are more efficient |
| 14-day window | 4.83s | (120, 6) | Default setting |
| 21-day window | 5.90s | (80, 6) | Slower with larger windows |
| Quantile bounds (0.1, 0.9) | 4.94s | (120, 6) | Minimal impact |
| Quantile bounds (0.01, 0.99) | 4.78s | (80, 6) | Minimal impact |

## Technical Analysis

### SQL Query Complexity Analysis

The `robust=True` implementation generates a highly complex SQL query:
- **Query Length**: 14,409 characters
- **Number of JOINs**: 7
- **Window Functions**: Multiple `QUANTILE_CONT` operations with complex range specifications
- **Subqueries**: Nested CTEs for variance calculations

### Why is robust=True Slow?

The winsorized variance calculation in the original Ibis implementation requires:

1. **Complex Window Joins**: For each data point, the algorithm performs multiple self-joins to calculate quantiles within different time windows
2. **Quantile Calculations**: Computing 5th and 95th percentiles for each window requires sorting operations across the entire window
3. **Multiple Variance Computations**: Left, right, and combined window variances are calculated separately with different window frames
4. **Join Complexity**: The implementation uses 7 JOINs to combine variance results back to the original data

### Why Alternative Implementations Failed

1. **Pandas/NumPy Approach**: 
   - Uses O(nÂ²) nested loops for window calculations per entity
   - Lacks the SQL query optimization that Ibis provides
   - Memory inefficient for large datasets
   - No vectorization benefits for complex window operations

2. **Polars Approach**: 
   - Similar algorithmic complexity issues
   - Conversion overhead between Polars and Pandas
   - Not leveraging SQL backend optimizations
   - Window operations not as mature as SQL implementations

### Ibis Implementation Strengths

The original Ibis implementation is well-designed because:

1. **SQL Optimization**: Leverages DuckDB's sophisticated query optimizer for efficient execution
2. **Vectorized Operations**: Uses SQL window functions which are highly optimized in modern databases
3. **Memory Efficiency**: Streaming operations without loading full intermediate datasets into memory
4. **Join Optimization**: SQL engine optimizes complex join operations better than manual implementations

## Optimization Insights

### What We Learned

1. **SQL is Superior**: For complex analytical operations like winsorized variance, SQL engines outperform manual implementations
2. **Window Size Matters**: Smaller rolling windows (7 days vs 21 days) provide better performance
3. **Quantile Bounds**: The specific quantile values (0.05/0.95 vs 0.1/0.9) have minimal performance impact
4. **Scaling Behavior**: Performance degradation is super-linear with dataset size, suggesting O(n log n) or O(nÂ²) complexity

### Alternative Approaches Considered

1. **Caching Strategy**: Pre-computing quantiles - not feasible due to dynamic window nature
2. **Approximation Algorithms**: Using sampling for quantile estimation - would change algorithm semantics
3. **Chunking**: Processing data in smaller pieces - would break temporal dependencies
4. **Hybrid Methods**: Using robust=False for screening - possible user-level optimization

## Recommendations

### For Current Users

1. **Evaluate Necessity**: Consider if `robust=True` is essential for your use case
   - Standard variance (`robust=False`) may be sufficient for many applications
   - The 3-40x performance penalty should be weighed against the robustness benefits

2. **Parameter Optimization**: If robust variance is necessary:
   - **Use smaller window sizes** when possible (7 days vs 14+ days)
   - Consider preprocessing to remove obvious outliers before changepoint detection
   - Use sampling strategies for exploratory analysis
   - Process data in smaller entity chunks if temporal dependencies allow

3. **Infrastructure Considerations**:
   - Ensure adequate computational resources for large datasets with `robust=True`
   - Consider running as background jobs for large datasets (>50k rows)
   - Monitor memory usage as dataset size scales
   - Plan for 10-40x longer execution times compared to `robust=False`

### For Future Development

1. **Documentation Enhancement**: 
   - Add performance warnings to the `robust=True` parameter documentation
   - Provide performance guidelines based on dataset size
   - Include examples of when `robust=False` might be sufficient

2. **Algorithm Research**: 
   - Investigate alternative robust variance estimators (e.g., trimmed variance, MAD-based estimates)
   - Consider approximation algorithms for very large datasets
   - Research streaming algorithms for winsorized variance

3. **User Experience Improvements**:
   - Add progress indicators for long-running `robust=True` operations
   - Implement automatic fallback suggestions when operations take too long
   - Provide dataset size warnings before execution

4. **Hybrid Approaches**:
   - Implement two-pass algorithm: use `robust=False` for initial screening, then `robust=True` for suspicious periods
   - Add sampling-based approximation mode for very large datasets

## Technical Specifications

### Test Environment
- **OS**: Linux 6.12.8+
- **Python**: 3.13.3
- **Ibis Framework**: 10.8.0
- **Pandas**: 2.3.2
- **NumPy**: 2.3.2
- **DuckDB**: 1.3.2
- **Polars**: 1.32.3

### Methodology
- Dataset scaling via entity ID replication (maintains temporal structure and relationships)
- Consistent parameters across all tests (`score_threshold=0.7`, `rolling_window_days=14`)
- Timeout protection for long-running operations (120-300 seconds)
- Result validation for correctness using existing unit tests
- Multiple implementation approaches tested (Pandas/NumPy, Polars, hybrid)

### Sample Data Characteristics
- **Base Dataset**: 5,768 rows, 3 entities
- **Time Range**: 2025-06-30 to 2025-08-03 (34 days)
- **Frequency**: 15-minute intervals
- **Data Type**: Travel time measurements in seconds
- **Scaling**: Up to 288,400 rows, 150 entities for performance testing

## Conclusion

The **original Ibis implementation with `robust=True` is already well-optimized** within the constraints of the winsorized variance algorithm. The performance characteristics observed (3-40x slower than `robust=False`) appear to be inherent to the computational complexity of robust variance estimation rather than implementation inefficiencies.

The complex SQL query with 7 JOINs and multiple window functions represents a sophisticated and efficient approach to calculating winsorized variance in a SQL environment. Alternative implementations using Pandas/NumPy or Polars are significantly slower due to their inability to leverage SQL query optimization.

**Final Recommendation**: **Continue using the current implementation** - it is already optimal. However, enhance documentation to clearly communicate the performance implications of `robust=True` and provide guidelines for users working with large datasets.

### Performance Guidelines for Users

| Dataset Size | Entities | Expected robust=True Time | Recommendation |
|-------------|----------|---------------------------|----------------|
| < 10k rows | < 10 | < 1 second | âœ… Use robust=True freely |
| 10k-50k rows | 10-50 | 1-5 seconds | âš ï¸ Consider necessity |
| 50k-100k rows | 50-100 | 5-15 seconds | âš ï¸ Evaluate alternatives |
| 100k-200k rows | 100-200 | 15-30 seconds | ðŸ”„ Use chunking or sampling |
| > 200k rows | > 200 | > 30 seconds | ðŸš« Consider robust=False or preprocessing |

### Quick Performance Optimization Tips

1. **Reduce window size**: Use `rolling_window_days=7` instead of `14` for ~33% speed improvement
2. **Preprocess outliers**: Remove obvious outliers before applying `robust=True`
3. **Entity chunking**: Process large datasets in smaller entity groups when possible
4. **Hybrid approach**: Use `robust=False` for initial analysis, then `robust=True` for specific periods of interest